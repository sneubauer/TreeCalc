.calcs size=34
.calc calc=0 name=P_TESTFUNNY nargs=1 computenode=2
.calc calc=1 name=P_SINGLE_COLLX nargs=0 computenode=2
.calc calc=2 name=P_SINGLE_FIRST nargs=0 computenode=2
.calc calc=3 name=P_SUB1_COLLX nargs=0 computenode=2
.calc calc=4 name=P_SUB2_COLLX nargs=0 computenode=2
.calc calc=5 name=P_SUB123_COLLX nargs=0 computenode=2
.calc calc=6 name=P_SUB123_FIRST nargs=0 computenode=2
.calc calc=7 name=P_SUB123_SECOND nargs=0 computenode=2
.calc calc=8 name=P_SUB123__COLLX nargs=0 computenode=2
.calc calc=9 name=P_SUB12_COLLX nargs=0 computenode=2
.calc calc=10 name=P_SUB3_COLLX nargs=0 computenode=2
.calc calc=11 name=P_SUB3__COLLX nargs=0 computenode=2
.calc calc=12 name=P_SINGLE nargs=0 computenode=3
.calc calc=13 name=P_SUM1 nargs=0 computenode=3
.calc calc=14 name=P_SUM2 nargs=0 computenode=3
.calc calc=15 name=P_SUM123 nargs=0 computenode=3
.calc calc=16 name=P_SUM123_ nargs=0 computenode=3
.calc calc=17 name=P_SUM12 nargs=0 computenode=3
.calc calc=18 name=P_SUM3 nargs=0 computenode=3
.calc calc=19 name=P_SUM3_ nargs=0 computenode=3
.calc calc=20 name=P_SUB1 nargs=0 computenode=4
.calc calc=21 name=P_SUB12 nargs=0 computestartnode=3
.calc calc=22 name=P_SUB123 nargs=0 computestartnode=3
.calc calc=23 name=P_SUB123_ nargs=0 computestartnode=3
.calc calc=24 name=P_SUB2 nargs=0 computenode=5
.calc calc=25 name=P_SUB3 nargs=0 computenode=6
.calc calc=26 name=P_SUB3_ nargs=0 computestartnode=6
.calc calc=27 name=P_OPTIONAL nargs=0 computestartnode=2
.calc calc=28 name=P_MULT nargs=1 computenode=13
.calc calc=29 name=P_MULT2 nargs=1 computenode=13
.calc calc=30 name=P_N nargs=0 computestartnode=14
.calc calc=31 name=P_Z nargs=0 computenode=15
.calc calc=32 name=P_FAC nargs=1 computenode=15
.calc calc=33 name=P_ZSUB nargs=0 computenode=15
.nodes size=17
.node node=0 id=maintree ;maintree
.calctotal node=0 calc_rangestart=0 calc_rangeend=33
.edges from=0 size=1
.edge ind=0 from=0 to=1
.node node=1 id=mytree ;mytree
.calctotal node=1 calc_rangestart=0 calc_rangeend=33
.edges from=1 size=3
.edge ind=0 from=1 to=2
.edge ind=1 from=1 to=14
.edge ind=2 from=1 to=15
.node node=2 id=m ;mytree.m
.nodecalc node=2 calc=0 formula=2
.nodecalc node=2 calc=1 formula=3
.nodecalc node=2 calc=2 formula=4
.nodecalc node=2 calc=3 formula=5
.nodecalc node=2 calc=4 formula=6
.nodecalc node=2 calc=5 formula=7
.nodecalc node=2 calc=6 formula=8
.nodecalc node=2 calc=7 formula=9
.nodecalc node=2 calc=8 formula=10
.nodecalc node=2 calc=9 formula=11
.nodecalc node=2 calc=10 formula=12
.nodecalc node=2 calc=11 formula=13
.calcdef node=2 calc_rangestart=0 calc_rangeend=11
.calctotal node=2 calc_rangestart=0 calc_rangeend=29
.edges from=2 size=4
.edge ind=0 from=2 to=3
.edge ind=1 from=2 to=9
.edge ind=2 from=2 to=10
.edge ind=3 from=2 to=13
.node node=3 id=maincomputes ;mytree.m.maincomputes
.nodecalc node=3 calc=12 formula=14
.nodecalc node=3 calc=13 formula=15
.nodecalc node=3 calc=14 formula=16
.nodecalc node=3 calc=15 formula=17
.nodecalc node=3 calc=16 formula=18
.nodecalc node=3 calc=17 formula=19
.nodecalc node=3 calc=18 formula=20
.nodecalc node=3 calc=19 formula=21
.calcdef node=3 calc_rangestart=12 calc_rangeend=19
.calctotal node=3 calc_rangestart=12 calc_rangeend=26
.edges from=3 size=3
.edge ind=0 from=3 to=4
.edge ind=1 from=3 to=5
.edge ind=2 from=3 to=6
.node node=4 id=sub1 ;mytree.m.maincomputes.sub1
.nodecalc node=4 calc=20 formula=22
.nodecalc node=4 calc=21 formula=23
.nodecalc node=4 calc=22 formula=24
.nodecalc node=4 calc=23 formula=25
.calcdef node=4 calc_rangestart=20 calc_rangeend=23
.calctotal node=4 calc_rangestart=20 calc_rangeend=23
.edges from=4 size=0
.node node=5 id=sub2 ;mytree.m.maincomputes.sub2
.nodecalc node=5 calc=24 formula=26
.nodecalc node=5 calc=21 formula=27
.nodecalc node=5 calc=22 formula=28
.nodecalc node=5 calc=23 formula=29
.calcdef node=5 calc_rangestart=21 calc_rangeend=24
.calctotal node=5 calc_rangestart=21 calc_rangeend=24
.edges from=5 size=0
.node node=6 id=sub3 ;mytree.m.maincomputes.sub3
.nodecalc node=6 calc=25 formula=30
.nodecalc node=6 calc=22 formula=31
.calcdef node=6 calc=22
.calcdef node=6 calc=25
.calctotal node=6 calc_rangestart=22 calc_rangeend=23
.calctotal node=6 calc_rangestart=25 calc_rangeend=26
.edges from=6 size=2
.edge ind=0 from=6 to=7
.edge ind=1 from=6 to=8
.node node=7 id=sub31 ;mytree.m.maincomputes.sub3.sub31
.nodecalc node=7 calc=26 formula=32
.nodecalc node=7 calc=23 formula=33
.calcdef node=7 calc=23
.calcdef node=7 calc=26
.calctotal node=7 calc=23
.calctotal node=7 calc=26
.edges from=7 size=0
.node node=8 id=sub32 ;mytree.m.maincomputes.sub3.sub32
.nodecalc node=8 calc=26 formula=34
.nodecalc node=8 calc=23 formula=35
.calcdef node=8 calc=23
.calcdef node=8 calc=26
.calctotal node=8 calc=23
.calctotal node=8 calc=26
.edges from=8 size=0
.node node=9 id=optional_init ;mytree.m.optional_init
.nodecalc node=9 calc=27 formula=36
.calcdef node=9 calc=27
.calctotal node=9 calc=27
.edges from=9 size=0
.node node=10 id=optional ;mytree.m.optional
.nodeformulas node=10 inclusion=37
.calctotal node=10 calc=27
.edges from=10 size=2
.edge ind=0 from=10 to=11
.edge ind=1 from=10 to=12
.node node=11 id=opt1 ;mytree.m.optional.opt1
.nodecalc node=11 calc=27 formula=38
.calcdef node=11 calc=27
.calctotal node=11 calc=27
.edges from=11 size=0
.node node=12 id=opt2 ;mytree.m.optional.opt2
.nodeformulas node=12 inclusion=39
.nodecalc node=12 calc=27 formula=40
.calcdef node=12 calc=27
.calctotal node=12 calc=27
.edges from=12 size=0
.node node=13 id=funny ;mytree.m.funny
.nodecalc node=13 calc=28 formula=41
.nodecalc node=13 calc=29 formula=42
.calcdef node=13 calc_rangestart=28 calc_rangeend=29
.calctotal node=13 calc_rangestart=28 calc_rangeend=29
.edges from=13 size=0
.node node=14 id=n ;mytree.n
.nodeformulas node=14 inclusion=43
.nodecalc node=14 calc=30 formula=44
.calcdef node=14 calc=30
.calctotal node=14 calc=30
.edges from=14 size=0
.node node=15 id=z ;mytree.z
.nodecalc node=15 calc=31 formula=45
.nodecalc node=15 calc=32 formula=46
.nodecalc node=15 calc=33 formula=47
.calcdef node=15 calc_rangestart=31 calc_rangeend=33
.calctotal node=15 calc_rangestart=31 calc_rangeend=33
.edges from=15 size=1
.edge ind=0 from=15 to=16
.node node=16 id=zsub ;mytree.z.zsub
.nodecalc node=16 calc=33 formula=48
.calcdef node=16 calc=33
.calctotal node=16 calc=33
.edges from=16 size=0
.tables size=0
.funcs size=2
.func func=0 name=F_TESTFUNNY args=1 formula=49
.func func=1 name=$VERSION args=0 formula=50
.inputcalcids size=0
.inputs size=2
.input input=0 name=I_INCLUDE_LEVEL1 autocounters=0 choiceable=false
.input input=1 name=I_INCLUDE_LEVEL2 autocounters=0 choiceable=false
.formulas size=51
.formula formula=0 simple=true
   ; argument 0: arguments_list
   ; argument 1: nodeid
   ; argument 2: calcid
   ; argument 3: nr of parameters
   ; argument 4: selfcall (0/1)
   ; argument 5: result
   ; localvar 6: formulaid_inclusion
   ; localvar 7: formulaid_times
   ; localvar 8: children_num
   ; localvar 9: children_ind
   ; localvar 10: times
   ; localvar 11: timescounter
   ; localvar 12: timesid
   ; localvar 13: formulaid for node-calc
   ; localvar 14: subnodeid
   : load 4 //selfcall
   : iffalse L1
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcown
   : iffalse L1
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 6 //formulaid_inclusion
   : ifnull L2 //jump if formulaid_inclusion<0
   : load 7 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L2
   ; node is not included -> do not append anything
   : load 5
   : return
 L2: //calc in own node, node is included
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 7 //formulaid_times
   : ifnull L3 //if no formulaid_times -> no times-counter
   : load 7 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   : store 10 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 12 //store timesid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 11   //init timescounter
   : load 12 //timesid
   : times_push
   // get and store formulaid
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : store 13
   : load 5 //result
 L8: // start of loop over times .. calc in own node, node is included, we have a multiple-counter
   ; action: compute and add to result
   : load 13 //result formulaid
   : load 3 //result formulaid nargs
   : load 0 //result formulaid nargs args_list
   : callformuladyn //result newvalue
   : listappendelem1 //result
   : times_inctop
   : load 11 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 11 //result timescounter+1
   : load 10 //result timescounter+1 times
   : ifsml L8
   : times_pop
   : return
 L3: //calc in own node, node is included, no multiple-counter
   : load 5 //result
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : load 3 //formulaid nargs
   : load 0 //formulaid nargs args_list
   : callformuladyn //result newvalue
   : listappendelem1 //result
   : return
 L1: //not defined in own node -> check if in child nodes
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalctotal
   : iftrue L6
     //not in child nodes -> return result unchanged
   : load 5
   : return
 L6: //defined in child nodes
   ; check if the node is included
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 6 //formulaid_inclusion
   : ifnull L61 //jump if formulaid_inclusion<0
   : load 6 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L61
   ; node is not included -> return 'null'
   : pushnull
   : return
L61: //defined in child nodes, and child node is included
   : load 1 //nodeid
   : tree_subnodes_counter //numchilds
   : dup //numchilds numchilds
   : ifzero L7 //numchilds; if no children -> return null
   : store 8 //store numchilds; --
   : pushconst0 //init indchild
   : store 9
   ; check times
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 7 //formulaid_times
   : ifnull L40 //if no formulaid_times -> no times-counter
   : load 7 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   ; setup times-counter
   : store 10 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 12 //store timesid
     // sum from children, we have times-counter -> outer loop over children, inner loop over times-counter
 L9: ;outer loop over children begin
   ; get subnode-id
   : load 1 //nodeid
   : load 9 //nodeid indchild
   : tree_subnodes_get //subnodeid
   : store 14 //store subnodeid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 11   //init timescounter
   : load 12 //timesid
   : times_push
 LA: //begin of inner loop over times
   : load 0; argument 0: arguments_list
   : load 14; argument 1: nodeid
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : load 5; argument 5: result
   : callformula 0 6 //recursive call -- newvalue
   : pop //result newvalue -- result; value was already appended to result list
   //increment and check times
   : times_inctop
   : load 11 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 11 //result timescounter+1
   : load 10 //result timescounter+1 times
   : ifsml LA
   : times_pop
   // increment and check current child
   : load 9 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 9 //result indchild+1
   : load 8 //result indchild+1 numchilds
   : ifsml L9 //result
   : load 5
   : return
L40: //sum from children, we are included and have no times-counter
L41: ;loop over children begin
   : load 0; argument 0: arguments_list
   ; push arguments for tree_subnodes_get
   : load 1 //nodeid
   : load 9 //indchild
   : tree_subnodes_get //argument 1: nodeid of child
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : load 5; argument 5: result
   : callformula 0 6 //recursive call -- newvalue
   : pop //newvalue already appended to the list
   // increment and check current child
   : load 9 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 9 //result indchild+1
   : load 8 //result indchild+1 numchilds
   : ifsml L41 //result
   : load 5
   : return
 L7: //no children or times-counter<=0 -> return result unchanged
   : load 5
   : return
.formuladone
.formula formula=1 simple=true
   ; argument 0: arguments_list
   ; argument 1: nodeid
   ; argument 2: calcid
   ; argument 3: nr of parameters
   ; argument 4: selfcall (0/1)
   ; localvar 5: formulaid_inclusion
   ; localvar 6: formulaid_times
   ; localvar 7: children_num
   ; localvar 8: children_ind
   ; localvar 9: times
   ; localvar 10: timescounter
   ; localvar 11: timesid
   ; localvar 12: formulaid for node-calc
   ; localvar 13: subnodeid
   : load 4 //selfcall
   : iffalse L1
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcown
   : iffalse L1
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 5 //formulaid_inclusion
   : ifnull L2 //jump if formulaid_inclusion<0
   : load 5 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L2
   ; node is not included -> return 'null'
   : pushnull
   : return
 L2: //calc in own node, node is included
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 6 //formulaid_times
   : ifnull L3 //if no formulaid_times -> no times-counter
   : load 6 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   : store 9 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 11 //store timesid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 10   //init timescounter
   : load 11 //timesid
   : times_push
   // get and store formulaid
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : store 12
   : pushnull //result
 L8: // start of loop over times .. calc in own node, node is included, we have a multiple-counter
   ; action: compute and add to result
   : load 12 //result formulaid
   : load 3 //result formulaid nargs
   : load 0 //result formulaid nargs args_list
   : callformuladyn //result newvalue
   : addnotnull //result
   : times_inctop
   : load 10 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 10 //result timescounter+1
   : load 9 //result timescounter+1 times
   : ifsml L8
   : times_pop
   : return
 L3: //calc in own node, node is included, no multiple-counter
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : load 3 //formulaid nargs
   : load 0 //formulaid nargs args_list
   : callformuladyn //result
   : return
 L1: //not defined in own node -> check if in child nodes
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalctotal
   : iftrue L6
     //not in child nodes -> return null
   : pushnull
   : return
 L6: //defined in child nodes
   ; check if the node is included
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 5 //formulaid_inclusion
   : ifnull L61 //jump if formulaid_inclusion<0
   : load 5 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L61
   ; node is not included -> return 'null'
   : pushnull
   : return
L61: //sum from subnodes, the node is included
   : load 1 //nodeid
   : tree_subnodes_counter //numchilds
   : dup //numchilds numchilds
   : ifzero L7 //numchilds; if no children -> return null
   : store 7 //store numchilds; --
   : pushconst0 //init indchild
   : store 8
   ; check times
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 6 //formulaid_times
   : ifnull L40 //if no formulaid_times -> no times-counter
   : load 6 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   ; setup times-counter
   : store 9 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 11 //store timesid
     // sum from children, we have times-counter -> outer loop over children, inner loop over times-counter
   : pushnull //result
 L9: ;outer loop over children begin
   ; get subnode-id
   : load 1 //nodeid
   : load 8 //nodeid indchild
   : tree_subnodes_get //subnodeid
   : store 13 //store subnodeid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 10   //init timescounter
   : load 11 //timesid
   : times_push
 LA: //begin of inner loop over times
   : load 0; argument 0: arguments_list
   : load 13; argument 1: nodeid
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : callformula 1 5 //recursive call -- result newvalue
   : addnotnull //add result -- result
   //increment and check times
   : times_inctop
   : load 10 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 10 //result timescounter+1
   : load 9 //result timescounter+1 times
   : ifsml LA
   : times_pop
   // increment and check current child
   : load 8 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 8 //result indchild+1
   : load 7 //result indchild+1 numchilds
   : ifsml L9 //result
   : return
L40: //sum from children, we are included and have no times-counter
   : pushnull
L41: ;loop over children begin
   : load 0; argument 0: arguments_list
   ; push arguments for tree_subnodes_get
   : load 1 //nodeid
   : load 8 //indchild
   : tree_subnodes_get //argument 1: nodeid of child
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : callformula 1 5 //recursive call -- result newvalue
   : addnotnull //add result -- result
   // increment and check current child
   : load 8 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 8 //result indchild+1
   : load 7 //result indchild+1 numchilds
   : ifsml L41 //result
   : return
 L7: //no children or times-counter<=0 -> return null
   : pushnull
   : return
.formuladone
.formula formula=2 simple=false ; line 45
   : load 0 ; I
   : callfunc 0 1 ; F_TESTFUNNY
   : return
.formuladone
.formula formula=3 simple=false ; line 46
   // start collate with single node/calc
   : callnodecalc 3 12 0 ;  node maincomputes calc P_SINGLE:0
   : createlist1
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=4 simple=false ; line 47
   : pushconst 0
   // start collate with single node/calc
   : callnodecalc 3 12 0 ;  node maincomputes calc P_SINGLE:0
   : createlist1
   : listelem1 ; extract from collate
   : return
.formuladone
.formula formula=5 simple=false ; line 48
   // start collate with single node/calc
   : callnodecalc 4 20 0 ;  node sub1 calc P_SUB1:0
   : createlist1
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=6 simple=false ; line 49
   // start collate with single node/calc
   : callnodecalc 5 24 0 ;  node sub2 calc P_SUB2:0
   : createlist1
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=7 simple=false ; line 50
   : callnodecalclist 3 22 0 1 ;  node maincomputes calc P_SUB123:0
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=8 simple=false ; line 51
   : pushconst 0
   : callnodecalclist 3 22 0 1 ;  node maincomputes calc P_SUB123:0
   : listelem1 ; extract from collate
   : return
.formuladone
.formula formula=9 simple=false ; line 52
   : pushconst 1
   : callnodecalclist 3 22 0 1 ;  node maincomputes calc P_SUB123:0
   : listelem1 ; extract from collate
   : return
.formuladone
.formula formula=10 simple=false ; line 53
   : callnodecalclist 3 23 0 1 ;  node maincomputes calc P_SUB123_:0
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=11 simple=false ; line 54
   : callnodecalclist 3 21 0 1 ;  node maincomputes calc P_SUB12:0
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=12 simple=false ; line 55
   // start collate with single node/calc
   : callnodecalc 6 25 0 ;  node sub3 calc P_SUB3:0
   : createlist1
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=13 simple=false ; line 56
   : callnodecalclist 6 26 0 1 ;  node sub3 calc P_SUB3_:0
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=14 simple=true ; line 70
   : pushconst "01"
   : return
.formuladone
.formula formula=15 simple=false ; line 71
   : callnodecalc 4 20 0 ;  node sub1 calc P_SUB1:0
   : return
.formuladone
.formula formula=16 simple=false ; line 72
   : callnodecalc 5 24 0 ;  node sub2 calc P_SUB2:0
   : return
.formuladone
.formula formula=17 simple=false ; line 73
   : callnodecalcsum 3 22 0 1 ;  node maincomputes calc P_SUB123:0
   : return
.formuladone
.formula formula=18 simple=false ; line 74
   : callnodecalcsum 3 23 0 1 ;  node maincomputes calc P_SUB123_:0
   : return
.formuladone
.formula formula=19 simple=false ; line 75
   : callnodecalcsum 3 21 0 1 ;  node maincomputes calc P_SUB12:0
   : return
.formuladone
.formula formula=20 simple=false ; line 76
   : callnodecalc 6 25 0 ;  node sub3 calc P_SUB3:0
   : return
.formuladone
.formula formula=21 simple=false ; line 77
   : callnodecalcsum 6 26 0 1 ;  node sub3 calc P_SUB3_:0
   : return
.formuladone
.formula formula=22 simple=true ; line 80
   : pushconst 1
   : return
.formuladone
.formula formula=23 simple=true ; line 81
   : pushconst 1
   : return
.formuladone
.formula formula=24 simple=true ; line 82
   : pushconst 1
   : return
.formuladone
.formula formula=25 simple=true ; line 83
   : pushconst 1
   : return
.formuladone
.formula formula=26 simple=true ; line 86
   : pushconst 2
   : return
.formuladone
.formula formula=27 simple=true ; line 87
   : pushconst 2
   : return
.formuladone
.formula formula=28 simple=true ; line 88
   : pushconst 2
   : return
.formuladone
.formula formula=29 simple=true ; line 89
   : pushconst 2
   : return
.formuladone
.formula formula=30 simple=true ; line 92
   : pushconst 4
   : return
.formuladone
.formula formula=31 simple=true ; line 93
   : pushconst 4
   : return
.formuladone
.formula formula=32 simple=true ; line 96
   : pushconst 8
   : return
.formuladone
.formula formula=33 simple=true ; line 97
   : pushconst 8
   : return
.formuladone
.formula formula=34 simple=true ; line 100
   : pushconst 16
   : return
.formuladone
.formula formula=35 simple=true ; line 101
   : pushconst 16
   : return
.formuladone
.formula formula=36 simple=true ; line 60
   : pushconst 0
   : return
.formuladone
.formula formula=37 simple=true ; line 12
   : getinput0 0 ; I_INCLUDE_LEVEL1
   : return
.formuladone
.formula formula=38 simple=true ; line 63
   : pushconst 1
   : return
.formuladone
.formula formula=39 simple=true ; line 14
   : getinput0 1 ; I_INCLUDE_LEVEL2
   : return
.formuladone
.formula formula=40 simple=true ; line 66
   : pushconst 2
   : return
.formuladone
.formula formula=41 simple=true ; line 38
   : load 0 ; I
   : return
.formuladone
.formula formula=42 simple=false ; line 39
   : load 0 ; IND
   : callnodecalc 13 28 1 ;  node funny calc P_MULT:1
   : return
.formuladone
.formula formula=43 simple=true ; line 18
   : getinput0 0 ; I_INCLUDE_LEVEL1
   : return
.formuladone
.formula formula=44 simple=true ; line 27
   : pushconst "n"
   : return
.formuladone
.formula formula=45 simple=true ; line 30
   : pushconst "z"
   : return
.formuladone
.formula formula=46 simple=false ; line 31
   //start of if statement, line 31
   : load 0 ; N
   : pushconst 0
   : cmpsmleq
   : iffalse L0
   : pushconst 1
   : goto L1
 L0:
   : load 0 ; N
   : pushconst 1
   : sub
   : callnodecalc 15 32 1 ;  node z calc P_FAC:1
   : load 0 ; N
   : mult
 L1:
   //end of if statement
   : return
.formuladone
.formula formula=47 simple=false ; line 32
   : callnodecalc 16 33 0 ;  node zsub calc P_ZSUB:0
   : return
.formuladone
.formula formula=48 simple=true ; line 35
   : pushconst 1
   : return
.formuladone
.formula formula=49 simple=false ; line 42
   : load 0 ; I
   : callnodecalc 13 28 1 ;  node funny calc P_MULT:1
   : return
.formuladone
.formula formula=50 simple=true ; line 0
   : pushconst "TcGen 23.05.2012 10:24:01"
   : return
.formuladone
