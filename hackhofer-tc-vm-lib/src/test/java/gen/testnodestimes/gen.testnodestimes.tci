.calcs size=11
.calc calc=0 name=P_TEST_COLLX nargs=0 computenode=2
.calc calc=1 name=P_TEST2INDEX_COLLX nargs=0 computenode=2
.calc calc=2 name=P_TEST2INDEX_3RD nargs=0 computenode=2
.calc calc=3 name=P_TEST nargs=0 computestartnode=2
.calc calc=4 name=P_TEST2 nargs=0 computestartnode=2
.calc calc=5 name=P_TEST2INDEX nargs=0 computestartnode=2
.calc calc=6 name=P_TEST2COMPUTE nargs=0 computestartnode=2
.calc calc=7 name=PX_LI_RIDERPREMIUMYEAR nargs=1 computestartnode=6
.calc calc=8 name=PX_LI_RIDERPREMIUMFREQ nargs=1 computestartnode=6
.calc calc=9 name=P_LI_RIDERPREMIUMYEARUNROUNDED nargs=1 computestartnode=8
.calc calc=10 name=P_LI_RIDERPREMIUMYEAR nargs=2 computestartnode=8
.nodes size=14
.node node=0 id=maintree ;maintree
.calctotal node=0 calc_rangestart=0 calc_rangeend=10
.edges from=0 size=1
.edge ind=0 from=0 to=1
.node node=1 id=mytree ;mytree
.calctotal node=1 calc_rangestart=0 calc_rangeend=10
.edges from=1 size=2
.edge ind=0 from=1 to=2
.edge ind=1 from=1 to=6
.node node=2 id=m ;mytree.m
.nodecalc node=2 calc=0 formula=2
.nodecalc node=2 calc=1 formula=3
.nodecalc node=2 calc=2 formula=4
.calcdef node=2 calc_rangestart=0 calc_rangeend=2
.calctotal node=2 calc_rangestart=0 calc_rangeend=6
.edges from=2 size=3
.edge ind=0 from=2 to=3
.edge ind=1 from=2 to=4
.edge ind=2 from=2 to=5
.node node=3 id=normal ;mytree.m.normal
.nodecalc node=3 calc=3 formula=5
.nodecalc node=3 calc=4 formula=6
.nodecalc node=3 calc=5 formula=7
.nodecalc node=3 calc=6 formula=8
.calcdef node=3 calc_rangestart=3 calc_rangeend=6
.calctotal node=3 calc_rangestart=3 calc_rangeend=6
.edges from=3 size=0
.node node=4 id=multiple1 ;mytree.m.multiple1
.nodeformulas node=4 timesformula=9 timesid=0
.nodecalc node=4 calc=3 formula=10
.calcdef node=4 calc=3
.calctotal node=4 calc=3
.edges from=4 size=0
.node node=5 id=multiple2 ;mytree.m.multiple2
.nodeformulas node=5 timesformula=11 timesid=1
.nodecalc node=5 calc=4 formula=12
.nodecalc node=5 calc=5 formula=13
.nodecalc node=5 calc=6 formula=14
.calcdef node=5 calc_rangestart=4 calc_rangeend=6
.calctotal node=5 calc_rangestart=4 calc_rangeend=6
.edges from=5 size=0
.node node=6 id=uro ;mytree.uro
.calctotal node=6 calc_rangestart=7 calc_rangeend=10
.edges from=6 size=2
.edge ind=0 from=6 to=7
.edge ind=1 from=6 to=8
.node node=7 id=Initialization ;mytree.uro.Initialization
.nodecalc node=7 calc=7 formula=15
.nodecalc node=7 calc=8 formula=16
.calcdef node=7 calc_rangestart=7 calc_rangeend=8
.calctotal node=7 calc_rangestart=7 calc_rangeend=8
.edges from=7 size=0
.node node=8 id=Main_results ;mytree.uro.Main_results
.nodeformulas node=8 inclusion=17
.nodecalc node=8 calc=7 formula=18
.nodecalc node=8 calc=8 formula=19
.nodecalc node=8 calc=9 formula=20
.calcdef node=8 calc_rangestart=7 calc_rangeend=9
.calctotal node=8 calc_rangestart=7 calc_rangeend=10
.edges from=8 size=1
.edge ind=0 from=8 to=9
.node node=9 id=Riders ;mytree.uro.Main_results.Riders
.calctotal node=9 calc=10
.edges from=9 size=2
.edge ind=0 from=9 to=10
.edge ind=1 from=9 to=11
.node node=10 id=Init ;mytree.uro.Main_results.Riders.Init
.nodecalc node=10 calc=10 formula=21
.calcdef node=10 calc=10
.calctotal node=10 calc=10
.edges from=10 size=0
.node node=11 id=Rider ;mytree.uro.Main_results.Riders.Rider
.nodeformulas node=11 timesformula=22 timesid=2
.calctotal node=11 calc=10
.edges from=11 size=1
.edge ind=0 from=11 to=12
.node node=12 id=AccDeath ;mytree.uro.Main_results.Riders.Rider.AccDeath
.calctotal node=12 calc=10
.edges from=12 size=1
.link ind=0 from=12 to=13
.node node=13 id=rider_calculation ;uro.component.rider_calculation
.nodecalc node=13 calc=10 formula=23
.calcdef node=13 calc=10
.calctotal node=13 calc=10
.edges from=13 size=0
.tables size=0
.funcs size=3
.func func=0 name=F_LI_INPUTOK args=0 formula=24
.func func=1 name=F_ROUND2RHD args=1 formula=25
.func func=2 name=$VERSION args=0 formula=26
.inputcalcids size=1
.inputcalcid icalc=0 name=DEFAULT
.inputs size=3
.input input=0 name=I_COUNTER autocounters=0 choiceable=false
.input input=1 name=I_COUNTER2 autocounters=0 choiceable=false
.input input=2 name=A_LI_RIDERS autocounters=0 choiceable=false
.inputcalc input=2 icalc=0 formula=27 ;DEFAULT
.formulas size=28
.formula formula=0 simple=true
   ; argument 0: arguments_list
   ; argument 1: nodeid
   ; argument 2: calcid
   ; argument 3: nr of parameters
   ; argument 4: selfcall (0/1)
   ; argument 5: result
   ; localvar 6: formulaid_inclusion
   ; localvar 7: formulaid_times
   ; localvar 8: children_num
   ; localvar 9: children_ind
   ; localvar 10: times
   ; localvar 11: timescounter
   ; localvar 12: timesid
   ; localvar 13: formulaid for node-calc
   ; localvar 14: subnodeid
   : load 4 //selfcall
   : iffalse L1
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcown
   : iffalse L1
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 6 //formulaid_inclusion
   : ifnull L2 //jump if formulaid_inclusion<0
   : load 7 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L2
   ; node is not included -> do not append anything
   : load 5
   : return
 L2: //calc in own node, node is included
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 7 //formulaid_times
   : ifnull L3 //if no formulaid_times -> no times-counter
   : load 7 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   : store 10 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 12 //store timesid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 11   //init timescounter
   : load 12 //timesid
   : times_push
   // get and store formulaid
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : store 13
   : load 5 //result
 L8: // start of loop over times .. calc in own node, node is included, we have a multiple-counter
   ; action: compute and add to result
   : load 13 //result formulaid
   : load 3 //result formulaid nargs
   : load 0 //result formulaid nargs args_list
   : callformuladyn //result newvalue
   : listappendelem1 //result
   : times_inctop
   : load 11 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 11 //result timescounter+1
   : load 10 //result timescounter+1 times
   : ifsml L8
   : times_pop
   : return
 L3: //calc in own node, node is included, no multiple-counter
   : load 5 //result
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : load 3 //formulaid nargs
   : load 0 //formulaid nargs args_list
   : callformuladyn //result newvalue
   : listappendelem1 //result
   : return
 L1: //not defined in own node -> check if in child nodes
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalctotal
   : iftrue L6
     //not in child nodes -> return result unchanged
   : load 5
   : return
 L6: //defined in child nodes
   ; check if the node is included
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 6 //formulaid_inclusion
   : ifnull L61 //jump if formulaid_inclusion<0
   : load 6 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L61
   ; node is not included -> return 'null'
   : pushnull
   : return
L61: //defined in child nodes, and child node is included
   : load 1 //nodeid
   : tree_subnodes_counter //numchilds
   : dup //numchilds numchilds
   : ifzero L7 //numchilds; if no children -> return null
   : store 8 //store numchilds; --
   : pushconst0 //init indchild
   : store 9
   ; check times
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 7 //formulaid_times
   : ifnull L40 //if no formulaid_times -> no times-counter
   : load 7 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   ; setup times-counter
   : store 10 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 12 //store timesid
     // sum from children, we have times-counter -> outer loop over children, inner loop over times-counter
 L9: ;outer loop over children begin
   ; get subnode-id
   : load 1 //nodeid
   : load 9 //nodeid indchild
   : tree_subnodes_get //subnodeid
   : store 14 //store subnodeid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 11   //init timescounter
   : load 12 //timesid
   : times_push
 LA: //begin of inner loop over times
   : load 0; argument 0: arguments_list
   : load 14; argument 1: nodeid
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : load 5; argument 5: result
   : callformula 0 6 //recursive call -- newvalue
   : pop //result newvalue -- result; value was already appended to result list
   //increment and check times
   : times_inctop
   : load 11 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 11 //result timescounter+1
   : load 10 //result timescounter+1 times
   : ifsml LA
   : times_pop
   // increment and check current child
   : load 9 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 9 //result indchild+1
   : load 8 //result indchild+1 numchilds
   : ifsml L9 //result
   : load 5
   : return
L40: //sum from children, we are included and have no times-counter
L41: ;loop over children begin
   : load 0; argument 0: arguments_list
   ; push arguments for tree_subnodes_get
   : load 1 //nodeid
   : load 9 //indchild
   : tree_subnodes_get //argument 1: nodeid of child
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : load 5; argument 5: result
   : callformula 0 6 //recursive call -- newvalue
   : pop //newvalue already appended to the list
   // increment and check current child
   : load 9 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 9 //result indchild+1
   : load 8 //result indchild+1 numchilds
   : ifsml L41 //result
   : load 5
   : return
 L7: //no children or times-counter<=0 -> return result unchanged
   : load 5
   : return
.formuladone
.formula formula=1 simple=true
   ; argument 0: arguments_list
   ; argument 1: nodeid
   ; argument 2: calcid
   ; argument 3: nr of parameters
   ; argument 4: selfcall (0/1)
   ; localvar 5: formulaid_inclusion
   ; localvar 6: formulaid_times
   ; localvar 7: children_num
   ; localvar 8: children_ind
   ; localvar 9: times
   ; localvar 10: timescounter
   ; localvar 11: timesid
   ; localvar 12: formulaid for node-calc
   ; localvar 13: subnodeid
   : load 4 //selfcall
   : iffalse L1
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcown
   : iffalse L1
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 5 //formulaid_inclusion
   : ifnull L2 //jump if formulaid_inclusion<0
   : load 5 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L2
   ; node is not included -> return 'null'
   : pushnull
   : return
 L2: //calc in own node, node is included
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 6 //formulaid_times
   : ifnull L3 //if no formulaid_times -> no times-counter
   : load 6 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   : store 9 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 11 //store timesid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 10   //init timescounter
   : load 11 //timesid
   : times_push
   // get and store formulaid
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : store 12
   : pushnull //result
 L8: // start of loop over times .. calc in own node, node is included, we have a multiple-counter
   ; action: compute and add to result
   : load 12 //result formulaid
   : load 3 //result formulaid nargs
   : load 0 //result formulaid nargs args_list
   : callformuladyn //result newvalue
   : addnotnull //result
   : times_inctop
   : load 10 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 10 //result timescounter+1
   : load 9 //result timescounter+1 times
   : ifsml L8
   : times_pop
   : return
 L3: //calc in own node, node is included, no multiple-counter
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : load 3 //formulaid nargs
   : load 0 //formulaid nargs args_list
   : callformuladyn //result
   : return
 L1: //not defined in own node -> check if in child nodes
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalctotal
   : iftrue L6
     //not in child nodes -> return null
   : pushnull
   : return
 L6: //defined in child nodes
   ; check if the node is included
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 5 //formulaid_inclusion
   : ifnull L61 //jump if formulaid_inclusion<0
   : load 5 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L61
   ; node is not included -> return 'null'
   : pushnull
   : return
L61: //sum from subnodes, the node is included
   : load 1 //nodeid
   : tree_subnodes_counter //numchilds
   : dup //numchilds numchilds
   : ifzero L7 //numchilds; if no children -> return null
   : store 7 //store numchilds; --
   : pushconst0 //init indchild
   : store 8
   ; check times
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 6 //formulaid_times
   : ifnull L40 //if no formulaid_times -> no times-counter
   : load 6 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   ; setup times-counter
   : store 9 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 11 //store timesid
     // sum from children, we have times-counter -> outer loop over children, inner loop over times-counter
   : pushnull //result
 L9: ;outer loop over children begin
   ; get subnode-id
   : load 1 //nodeid
   : load 8 //nodeid indchild
   : tree_subnodes_get //subnodeid
   : store 13 //store subnodeid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 10   //init timescounter
   : load 11 //timesid
   : times_push
 LA: //begin of inner loop over times
   : load 0; argument 0: arguments_list
   : load 13; argument 1: nodeid
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : callformula 1 5 //recursive call -- result newvalue
   : addnotnull //add result -- result
   //increment and check times
   : times_inctop
   : load 10 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 10 //result timescounter+1
   : load 9 //result timescounter+1 times
   : ifsml LA
   : times_pop
   // increment and check current child
   : load 8 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 8 //result indchild+1
   : load 7 //result indchild+1 numchilds
   : ifsml L9 //result
   : return
L40: //sum from children, we are included and have no times-counter
   : pushnull
L41: ;loop over children begin
   : load 0; argument 0: arguments_list
   ; push arguments for tree_subnodes_get
   : load 1 //nodeid
   : load 8 //indchild
   : tree_subnodes_get //argument 1: nodeid of child
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : callformula 1 5 //recursive call -- result newvalue
   : addnotnull //add result -- result
   // increment and check current child
   : load 8 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 8 //result indchild+1
   : load 7 //result indchild+1 numchilds
   : ifsml L41 //result
   : return
 L7: //no children or times-counter<=0 -> return null
   : pushnull
   : return
.formuladone
.formula formula=2 simple=false ; line 30
   : callnodecalclist 2 3 0 1 ;  node m calc P_TEST:0
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=3 simple=false ; line 31
   : callnodecalclist 2 5 0 1 ;  node m calc P_TEST2INDEX:0
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=4 simple=false ; line 32
   : pushconst 2
   : callnodecalclist 2 5 0 1 ;  node m calc P_TEST2INDEX:0
   : listelem1 ; extract from collate
   : return
.formuladone
.formula formula=5 simple=true ; line 36
   : pushconst 1
   : return
.formuladone
.formula formula=6 simple=true ; line 37
   : pushconst 1
   : return
.formuladone
.formula formula=7 simple=true ; line 38
   : pushconst 0
   : return
.formuladone
.formula formula=8 simple=true ; line 39
   : pushconst 0
   : return
.formuladone
.formula formula=9 simple=true ; line 4
   : getinput0 0 ; I_COUNTER
   : return
.formuladone
.formula formula=10 simple=true ; line 43
   : pushconst 1
   : return
.formuladone
.formula formula=11 simple=true ; line 5
   : getinput0 1 ; I_COUNTER2
   : return
.formuladone
.formula formula=12 simple=true ; line 46
   : pushconst 1
   : return
.formuladone
.formula formula=13 simple=true ; line 47
   : pushtimescounter 1 ; CURRENT_COUNTER2
   : return
.formuladone
.formula formula=14 simple=true ; line 48
   : pushconst 2
   : pushtimescounter 1 ; CURRENT_COUNTER2
   : power
   : return
.formuladone
.formula formula=15 simple=true ; line 52
   : pushconst 0
   : return
.formuladone
.formula formula=16 simple=true ; line 53
   : pushconst 0
   : return
.formuladone
.formula formula=17 simple=false ; line 9
   : callfunc 0 0 ; F_LI_INPUTOK
   : return
.formuladone
.formula formula=18 simple=false ; line 57
   : load 0 ; I
   : callnodecalcsum 8 8 1 1 ;  node Main_results calc PX_LI_RIDERPREMIUMFREQ:1
   : callfunc 1 1 ; F_ROUND2RHD
   : return
.formuladone
.formula formula=19 simple=false ; line 58
   : load 0 ; I
   : callnodecalcsum 8 9 1 1 ;  node Main_results calc P_LI_RIDERPREMIUMYEARUNROUNDED:1
   : callfunc 1 1 ; F_ROUND2RHD
   : return
.formuladone
.formula formula=20 simple=false ; line 59
   : load 0 ; I
   : pushconst 50000
   : callnodecalcsum 8 10 2 1 ;  node Main_results calc P_LI_RIDERPREMIUMYEAR:2
   : return
.formuladone
.formula formula=21 simple=true ; line 63
   : pushconst 0
   : return
.formuladone
.formula formula=22 simple=true ; line 12
   : getinput0 2 ; A_LI_RIDERS
   : return
.formuladone
.formula formula=23 simple=true ; line 68
   //start of if statement, line 68
   : load 0 ; I
   : pushtimescounter 2 ; CURRENT_A_LI_RIDERS
   : eq
   : iffalse L0
   : pushconst 70
   : goto L1
 L0:
   : pushconst 0
 L1:
   //end of if statement
   : return
.formuladone
.formula formula=24 simple=true ; line 26
   : pushconst 1
   : return
.formuladone
.formula formula=25 simple=false ; line 27
   //start of if statement, line 27
   : load 0 ; X
   : pushconst 0
   : cmpbig
   : iffalse L0
   : load 0 ; X
   : pushconst 0.0000001
   : add
   : goto L1
 L0:
   : load 0 ; X
   : pushconst 0.0000001
   : sub
 L1:
   //end of if statement
   : pushconst 2
   : builtin 22 2 ; ROUND
   : return
.formuladone
.formula formula=26 simple=true ; line 0
   : pushconst "TcGen 23.05.2012 10:24:02"
   : return
.formuladone
.formula formula=27 simple=true ; line 81
   : pushconst 0
   : return
.formuladone
