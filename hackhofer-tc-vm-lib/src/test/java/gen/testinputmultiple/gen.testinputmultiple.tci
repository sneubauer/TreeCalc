.calcs size=15
.calc calc=0 name=P_TESTINPUTX nargs=0 computenode=2
.calc calc=1 name=P_TESTINPUTCALCX nargs=0 computenode=2
.calc calc=2 name=P_TESTINPUTCALCX2 nargs=0 computenode=2
.calc calc=3 name=P_TESTINPUTCALCX3 nargs=0 computenode=2
.calc calc=4 name=P_TESTINDEX nargs=0 computestartnode=2
.calc calc=5 name=P_TESTINDEXBIN nargs=0 computestartnode=2
.calc calc=6 name=P_TEST nargs=0 computestartnode=2
.calc calc=7 name=P_AGEMANUAL nargs=0 computestartnode=2
.calc calc=8 name=P_AGEAUTO nargs=0 computestartnode=2
.calc calc=9 name=P_AGEFIRST nargs=0 computestartnode=2
.calc calc=10 name=P_FUNC nargs=0 computestartnode=2
.calc calc=11 name=P_TESTINPUT nargs=0 computestartnode=4
.calc calc=12 name=P_TESTINPUTCALC nargs=0 computestartnode=4
.calc calc=13 name=P_TESTINPUTCALC2 nargs=0 computestartnode=4
.calc calc=14 name=P_TESTINPUTCALC3 nargs=0 computestartnode=4
.nodes size=5
.node node=0 id=maintree ;maintree
.calctotal node=0 calc_rangestart=0 calc_rangeend=14
.edges from=0 size=1
.edge ind=0 from=0 to=1
.node node=1 id=maintree ;maintree
.calctotal node=1 calc_rangestart=0 calc_rangeend=14
.edges from=1 size=1
.edge ind=0 from=1 to=2
.node node=2 id=m ;maintree.m
.nodecalc node=2 calc=0 formula=2
.nodecalc node=2 calc=1 formula=3
.nodecalc node=2 calc=2 formula=4
.nodecalc node=2 calc=3 formula=5
.calcdef node=2 calc_rangestart=0 calc_rangeend=3
.calctotal node=2 calc_rangestart=0 calc_rangeend=14
.edges from=2 size=2
.edge ind=0 from=2 to=3
.edge ind=1 from=2 to=4
.node node=3 id=init ;maintree.m.init
.nodecalc node=3 calc=4 formula=6
.nodecalc node=3 calc=5 formula=7
.nodecalc node=3 calc=6 formula=8
.nodecalc node=3 calc=7 formula=9
.nodecalc node=3 calc=8 formula=10
.nodecalc node=3 calc=9 formula=11
.nodecalc node=3 calc=10 formula=12
.calcdef node=3 calc_rangestart=4 calc_rangeend=10
.calctotal node=3 calc_rangestart=4 calc_rangeend=10
.edges from=3 size=0
.node node=4 id=mult ;maintree.m.mult
.nodeformulas node=4 timesformula=13 timesid=0
.nodecalc node=4 calc=6 formula=14
.nodecalc node=4 calc=4 formula=15
.nodecalc node=4 calc=5 formula=16
.nodecalc node=4 calc=7 formula=17
.nodecalc node=4 calc=8 formula=18
.nodecalc node=4 calc=9 formula=19
.nodecalc node=4 calc=10 formula=20
.nodecalc node=4 calc=11 formula=21
.nodecalc node=4 calc=12 formula=22
.nodecalc node=4 calc=13 formula=23
.nodecalc node=4 calc=14 formula=24
.calcdef node=4 calc_rangestart=4 calc_rangeend=14
.calctotal node=4 calc_rangestart=4 calc_rangeend=14
.edges from=4 size=0
.tables size=0
.funcs size=3
.func func=0 name=F_TEST args=0 formula=25
.func func=1 name=F_TESTINPUT args=0 formula=26
.func func=2 name=$VERSION args=0 formula=27
.inputcalcids size=3
.inputcalcid icalc=0 name=CHECK
.inputcalcid icalc=1 name=VALUE
.inputcalcid icalc=2 name=AUTOCOUNTER
.inputs size=4
.input input=0 name=I_TESTINPUT autocounters=1 choiceable=false
.inputautocounter input=0 ind=0 counter=0
.inputcalc input=0 icalc=0 formula=28 ;CHECK
.inputcalc input=0 icalc=1 formula=29 ;VALUE
.inputcalc input=0 icalc=2 formula=30 ;AUTOCOUNTER
.input input=1 name=I_PERSONS autocounters=0 choiceable=false
.input input=2 name=I_AGE autocounters=0 choiceable=false
.input input=3 name=I_AGEAUTO autocounters=1 choiceable=false
.inputautocounter input=3 ind=0 counter=0
.inputcalc input=3 icalc=2 formula=31 ;AUTOCOUNTER
.formulas size=32
.formula formula=0 simple=true
   ; argument 0: arguments_list
   ; argument 1: nodeid
   ; argument 2: calcid
   ; argument 3: nr of parameters
   ; argument 4: selfcall (0/1)
   ; argument 5: result
   ; localvar 6: formulaid_inclusion
   ; localvar 7: formulaid_times
   ; localvar 8: children_num
   ; localvar 9: children_ind
   ; localvar 10: times
   ; localvar 11: timescounter
   ; localvar 12: timesid
   ; localvar 13: formulaid for node-calc
   ; localvar 14: subnodeid
   : load 4 //selfcall
   : iffalse L1
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcown
   : iffalse L1
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 6 //formulaid_inclusion
   : ifnull L2 //jump if formulaid_inclusion<0
   : load 7 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L2
   ; node is not included -> do not append anything
   : load 5
   : return
 L2: //calc in own node, node is included
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 7 //formulaid_times
   : ifnull L3 //if no formulaid_times -> no times-counter
   : load 7 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   : store 10 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 12 //store timesid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 11   //init timescounter
   : load 12 //timesid
   : times_push
   // get and store formulaid
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : store 13
   : load 5 //result
 L8: // start of loop over times .. calc in own node, node is included, we have a multiple-counter
   ; action: compute and add to result
   : load 13 //result formulaid
   : load 3 //result formulaid nargs
   : load 0 //result formulaid nargs args_list
   : callformuladyn //result newvalue
   : listappendelem1 //result
   : times_inctop
   : load 11 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 11 //result timescounter+1
   : load 10 //result timescounter+1 times
   : ifsml L8
   : times_pop
   : return
 L3: //calc in own node, node is included, no multiple-counter
   : load 5 //result
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : load 3 //formulaid nargs
   : load 0 //formulaid nargs args_list
   : callformuladyn //result newvalue
   : listappendelem1 //result
   : return
 L1: //not defined in own node -> check if in child nodes
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalctotal
   : iftrue L6
     //not in child nodes -> return result unchanged
   : load 5
   : return
 L6: //defined in child nodes
   ; check if the node is included
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 6 //formulaid_inclusion
   : ifnull L61 //jump if formulaid_inclusion<0
   : load 6 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L61
   ; node is not included -> return 'null'
   : pushnull
   : return
L61: //defined in child nodes, and child node is included
   : load 1 //nodeid
   : tree_subnodes_counter //numchilds
   : dup //numchilds numchilds
   : ifzero L7 //numchilds; if no children -> return null
   : store 8 //store numchilds; --
   : pushconst0 //init indchild
   : store 9
   ; check times
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 7 //formulaid_times
   : ifnull L40 //if no formulaid_times -> no times-counter
   : load 7 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   ; setup times-counter
   : store 10 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 12 //store timesid
     // sum from children, we have times-counter -> outer loop over children, inner loop over times-counter
 L9: ;outer loop over children begin
   ; get subnode-id
   : load 1 //nodeid
   : load 9 //nodeid indchild
   : tree_subnodes_get //subnodeid
   : store 14 //store subnodeid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 11   //init timescounter
   : load 12 //timesid
   : times_push
 LA: //begin of inner loop over times
   : load 0; argument 0: arguments_list
   : load 14; argument 1: nodeid
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : load 5; argument 5: result
   : callformula 0 6 //recursive call -- newvalue
   : pop //result newvalue -- result; value was already appended to result list
   //increment and check times
   : times_inctop
   : load 11 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 11 //result timescounter+1
   : load 10 //result timescounter+1 times
   : ifsml LA
   : times_pop
   // increment and check current child
   : load 9 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 9 //result indchild+1
   : load 8 //result indchild+1 numchilds
   : ifsml L9 //result
   : load 5
   : return
L40: //sum from children, we are included and have no times-counter
L41: ;loop over children begin
   : load 0; argument 0: arguments_list
   ; push arguments for tree_subnodes_get
   : load 1 //nodeid
   : load 9 //indchild
   : tree_subnodes_get //argument 1: nodeid of child
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : load 5; argument 5: result
   : callformula 0 6 //recursive call -- newvalue
   : pop //newvalue already appended to the list
   // increment and check current child
   : load 9 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 9 //result indchild+1
   : load 8 //result indchild+1 numchilds
   : ifsml L41 //result
   : load 5
   : return
 L7: //no children or times-counter<=0 -> return result unchanged
   : load 5
   : return
.formuladone
.formula formula=1 simple=true
   ; argument 0: arguments_list
   ; argument 1: nodeid
   ; argument 2: calcid
   ; argument 3: nr of parameters
   ; argument 4: selfcall (0/1)
   ; localvar 5: formulaid_inclusion
   ; localvar 6: formulaid_times
   ; localvar 7: children_num
   ; localvar 8: children_ind
   ; localvar 9: times
   ; localvar 10: timescounter
   ; localvar 11: timesid
   ; localvar 12: formulaid for node-calc
   ; localvar 13: subnodeid
   : load 4 //selfcall
   : iffalse L1
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcown
   : iffalse L1
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 5 //formulaid_inclusion
   : ifnull L2 //jump if formulaid_inclusion<0
   : load 5 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L2
   ; node is not included -> return 'null'
   : pushnull
   : return
 L2: //calc in own node, node is included
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 6 //formulaid_times
   : ifnull L3 //if no formulaid_times -> no times-counter
   : load 6 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   : store 9 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 11 //store timesid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 10   //init timescounter
   : load 11 //timesid
   : times_push
   // get and store formulaid
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : store 12
   : pushnull //result
 L8: // start of loop over times .. calc in own node, node is included, we have a multiple-counter
   ; action: compute and add to result
   : load 12 //result formulaid
   : load 3 //result formulaid nargs
   : load 0 //result formulaid nargs args_list
   : callformuladyn //result newvalue
   : addnotnull //result
   : times_inctop
   : load 10 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 10 //result timescounter+1
   : load 9 //result timescounter+1 times
   : ifsml L8
   : times_pop
   : return
 L3: //calc in own node, node is included, no multiple-counter
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalcformula //formulaid
   : load 3 //formulaid nargs
   : load 0 //formulaid nargs args_list
   : callformuladyn //result
   : return
 L1: //not defined in own node -> check if in child nodes
   : load 1 //nodeid
   : load 2 //calcid
   : tree_nodecalctotal
   : iftrue L6
     //not in child nodes -> return null
   : pushnull
   : return
 L6: //defined in child nodes
   ; check if the node is included
   : load 1 //nodeid
   : tree_nodeformulainc //formulaid
   : dup //formulaid_inclusion formulaid_inclusion
   : store 5 //formulaid_inclusion
   : ifnull L61 //jump if formulaid_inclusion<0
   : load 5 //formulaid_inclusion
   : pushconst0 //nargs=0
   : createlist0 //parameters (empty list)
   : callformuladyn //call inclusion formula
   : iftrue L61
   ; node is not included -> return 'null'
   : pushnull
   : return
L61: //sum from subnodes, the node is included
   : load 1 //nodeid
   : tree_subnodes_counter //numchilds
   : dup //numchilds numchilds
   : ifzero L7 //numchilds; if no children -> return null
   : store 7 //store numchilds; --
   : pushconst0 //init indchild
   : store 8
   ; check times
   : load 1 //nodeid
   : tree_nodeformulatimes //formulaid_times
   : dup //formulaid_times formulaid_times
   : store 6 //formulaid_times
   : ifnull L40 //if no formulaid_times -> no times-counter
   : load 6 //formulaid_times
   : pushconst0 //formulaid_times 0; no parameters
   : createlist0 //formulaid_times 0 []; parameters (empty list)
   : callformuladyn //times
   : dup //times times
   : pushconst0 //times times 0
   : ifsmleq L7 //times; counter<=0 -> return null
   ; setup times-counter
   : store 9 //store times
   : load 1 //nodeid
   : tree_nodetimesid //timesid
   : store 11 //store timesid
     // sum from children, we have times-counter -> outer loop over children, inner loop over times-counter
   : pushnull //result
 L9: ;outer loop over children begin
   ; get subnode-id
   : load 1 //nodeid
   : load 8 //nodeid indchild
   : tree_subnodes_get //subnodeid
   : store 13 //store subnodeid
   // init times counter in local var and on times-stack
   : pushconst0 //init timescounter
   : store 10   //init timescounter
   : load 11 //timesid
   : times_push
 LA: //begin of inner loop over times
   : load 0; argument 0: arguments_list
   : load 13; argument 1: nodeid
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : callformula 1 5 //recursive call -- result newvalue
   : addnotnull //add result -- result
   //increment and check times
   : times_inctop
   : load 10 //result timescounter
   : pushconst1 //result timescounter 1
   : add //result timescounter+1
   : dup //result timescounter+1 timescounter+1
   : store 10 //result timescounter+1
   : load 9 //result timescounter+1 times
   : ifsml LA
   : times_pop
   // increment and check current child
   : load 8 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 8 //result indchild+1
   : load 7 //result indchild+1 numchilds
   : ifsml L9 //result
   : return
L40: //sum from children, we are included and have no times-counter
   : pushnull
L41: ;loop over children begin
   : load 0; argument 0: arguments_list
   ; push arguments for tree_subnodes_get
   : load 1 //nodeid
   : load 8 //indchild
   : tree_subnodes_get //argument 1: nodeid of child
   : load 2; argument 2: calcid
   : load 3; argument 3: nr of parameters
   : pushconst1; argument 4: selfcall (0/1)
   : callformula 1 5 //recursive call -- result newvalue
   : addnotnull //add result -- result
   // increment and check current child
   : load 8 //result indchild
   : pushconst1 //result indchild 1
   : add //result indchild+1
   : dup //result indchild+1 indchild+1
   : store 8 //result indchild+1
   : load 7 //result indchild+1 numchilds
   : ifsml L41 //result
   : return
 L7: //no children or times-counter<=0 -> return null
   : pushnull
   : return
.formuladone
.formula formula=2 simple=false ; line 9
   : callnodecalclist 4 11 0 1 ;  node mult calc P_TESTINPUT:0
   : pushconst " - "
   : builtin 70 2 ; V_STRING
   : return
.formuladone
.formula formula=3 simple=false ; line 10
   : callnodecalclist 4 12 0 1 ;  node mult calc P_TESTINPUTCALC:0
   : pushconst " - "
   : builtin 70 2 ; V_STRING
   : return
.formuladone
.formula formula=4 simple=false ; line 11
   : callnodecalclist 4 13 0 1 ;  node mult calc P_TESTINPUTCALC2:0
   : pushconst " - "
   : builtin 70 2 ; V_STRING
   : return
.formuladone
.formula formula=5 simple=false ; line 12
   : callnodecalclist 4 14 0 1 ;  node mult calc P_TESTINPUTCALC3:0
   : pushconst " - "
   : builtin 70 2 ; V_STRING
   : return
.formuladone
.formula formula=6 simple=true ; line 17
   : pushconst 0
   : return
.formuladone
.formula formula=7 simple=true ; line 18
   : pushconst 0
   : return
.formuladone
.formula formula=8 simple=true ; line 19
   : pushconst 0
   : return
.formuladone
.formula formula=9 simple=true ; line 20
   : pushconst 0
   : return
.formuladone
.formula formula=10 simple=true ; line 21
   : pushconst 0
   : return
.formuladone
.formula formula=11 simple=true ; line 22
   : pushconst 0
   : return
.formuladone
.formula formula=12 simple=true ; line 23
   : pushconst 0
   : return
.formuladone
.formula formula=13 simple=true ; line 4
   : getinput0 1 ; I_PERSONS
   : return
.formuladone
.formula formula=14 simple=true ; line 27
   : pushconst 1
   : return
.formuladone
.formula formula=15 simple=true ; line 28
   : pushtimescounter 0 ; CURRENT_PERSON
   : return
.formuladone
.formula formula=16 simple=true ; line 29
   : pushconst 2
   : pushtimescounter 0 ; CURRENT_PERSON
   : power
   : return
.formuladone
.formula formula=17 simple=false ; line 30
   : pushtimescounter 0 ; CURRENT_PERSON
   : getinput 2 1 ; I_AGE
   : return
.formuladone
.formula formula=18 simple=true ; line 31
   : getinput0 3 ; I_AGEAUTO
   : return
.formuladone
.formula formula=19 simple=false ; line 32
   : pushconst 0
   : getinput 3 1 ; I_AGEAUTO
   : return
.formuladone
.formula formula=20 simple=false ; line 33
   : callfunc 0 0 ; F_TEST
   : return
.formuladone
.formula formula=21 simple=true ; line 34
   : getinputcalc0 0 1 ; I_TESTINPUT.VALUE
   : return
.formuladone
.formula formula=22 simple=true ; line 35
   : getinputcalc0 0 1 ; I_TESTINPUT.VALUE
   : return
.formuladone
.formula formula=23 simple=false ; line 36
   : callfunc 1 0 ; F_TESTINPUT
   : return
.formuladone
.formula formula=24 simple=false ; line 37
   : pushconst 2
   : pushconst 0
   : getinputcalc 0 1 2 ; I_TESTINPUT.VALUE
   : return
.formuladone
.formula formula=25 simple=true ; line 52
   : getinput0 3 ; I_AGEAUTO
   : return
.formuladone
.formula formula=26 simple=true ; line 54
   : getinputcalc0 0 1 ; I_TESTINPUT.VALUE
   : return
.formuladone
.formula formula=27 simple=true ; line 0
   : pushconst "TcGen 23.05.2012 10:24:01"
   : return
.formuladone
.formula formula=28 simple=false ; line 41
   : load 0 ; INDEX
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=29 simple=false ; line 42
   : load 0 ; INDEX
   : builtin 71 1 ; V_STRINGX
   : return
.formuladone
.formula formula=30 simple=false ; line 43
   : pushconst 1
   : createlistn 
   : dup
   : pushconst 0 ; counter CURRENT_PERSON
   : listappendelem1
   : return
.formuladone
.formula formula=31 simple=false ; line 49
   : pushconst 1
   : createlistn 
   : dup
   : pushconst 0 ; counter CURRENT_PERSON
   : listappendelem1
   : return
.formuladone
